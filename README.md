# Dagger Learning
Dagger 2 is a dependency injection (DI) framework, and dependency injection in build upon concept of Inversion of Control. Which says that a class should get its dependencies from outside. In simple words, no class should instantiate another class but should get instances from a configuration class.

A dependency consumer asks for dependency(Object) from a dependency provider through a connector.
1. Dependency provider: Classes annotated with "@Module" are responsible for providing objects which can be injected. This class defines the methods that provide the dependency. A Module class is identified by "@Module" and the dependency provider method in identified by "@Provides". The returned objects from these methods are available for dependency injection.
2. Dependecy consumer: The "@Inject" annotation is used to define a dependency
3. Connecting consumer and produces: A "@Component" annotated interface defines the connection between the provider of objects (modules) and the objects which express a dependency. The class for this connection is generated by the Dagger.

Limitations of Dagger:
1. Dagger does not inject fields automatically
2. It cannot inject private fields.
3. Have to define a method in @Component annotatated interface which takes the instance of the class into which you want to inject the member variable.

Some annotation in Dagger:
1. "@Singleton" = ensure a single instance of a class globally.
2. "@ApplicationContext Qualifier" facilitates class to get context object of the application from dagger's dependency graph
3. "@PerActivity" is a scope and is used to tell the Dagger that the Context and Activity provided by the ActivityModule will be instantiated each time an Activity is created.
4. "@Scope" = is used to specify the scope in which a dependency object persists. 
